use std::iter::FromIterator;
use std::num::Wrapping as w;

use rand::{Rng, SeedableRng, Rand};

pub fn xor_bytes(src: &[u8], xor: &[u8]) -> Vec<u8> {
    let xor_cycle = xor.iter().cycle();
    let res: Vec<u8> = src.iter()
        .zip(xor_cycle)
        .map(|(&a, &b)| a ^ b)
        .collect();
    res
}

// pretty naive divide and conquor bit counting
pub fn count_bits(mut x: u32) -> u32 {
    x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);
    x = (x & 0x00ff00ff) + ((x >> 8) & 0x00ff00ff);
    x = (x & 0x0000ffff) + ((x >> 16) & 0x0000ffff);
    x
}

pub fn hamming_dist(x: u32, y: u32) -> u32 {
    count_bits(x ^ y)
}

pub fn u8s_to_u32(xs: &[u8]) -> u32 {
    let a = *(xs.get(0).unwrap_or(&0)) as u32;
    let b = *(xs.get(1).unwrap_or(&0)) as u32;
    let c = *(xs.get(2).unwrap_or(&0)) as u32;
    let d = *(xs.get(3).unwrap_or(&0)) as u32;

    let mut x: u32 = d as u32;
    x += c << 8;
    x += b << 16;
    x += a << 24;
    x
}

pub fn bytes_hamming_dist(b1: &[u8], b2: &[u8]) -> u32 {
    let b2_u32s = b2.chunks(4)
        .map(|c| u8s_to_u32(c));
    b1.chunks(4)
        .map(|c| u8s_to_u32(c))
        .zip(b2_u32s)
        .map(|(x, y)| hamming_dist(x, y))
        .sum()
}

pub fn hexdump(b: &[u8]) {
    for bytes in b.chunks(16) {
        let hex_digits =  bytes.iter()
            .map(|x| format!("{:02x}", x))
            .collect::<Vec<_>>()
            .join(" ");
        let string = bytes.iter()
            .map(|&c| {
                if c >= 32 && c < 127 {
                    format!("{}", c as char)
                } else {
                    ".".to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("");
        print!("{} ", hex_digits);
        if bytes.len() != 16 {
            let padding = String::from_iter(vec![' '; 3 * (16 - bytes.len())]);
            print!("{}", &padding);
        }
        println!("{}", string);
    }
}

#[allow(bad_style)]
type w32 = w<u32>;

// Mersenne Twister 19937 Constants
const MW: usize = 32;
const MU: usize = 11;
const MS: usize = 7;
const ML: usize = 18;
const MT: usize = 15;
const MN: usize = 624;
const MM: usize = 397;
const M1: w32 = w(0x1_u32);
const MA: w32 = w(0x9908B0DF_u32);
const MB: w32 = w(0x9D2C5680_u32);
const MC: w32 = w(0xEFC60000_u32);
const MF: w32 = w(0x6C078965_u32);
const MPU: w32 = w(0x80000000_u32);
const MPL: w32 = w(0x7fffffff_u32);

#[allow(bad_style)]
pub struct MT19937Rng {
    i: usize,
    X: [w32; MN],
}

impl MT19937Rng {
    pub fn new_unseeded() -> MT19937Rng {
        let mut rng = MT19937Rng {
            i: MN,
            X: [w(0_u32); MN]
        };
        rng.reseed(5489);
        rng
    }

    #[allow(bad_style)]
    fn twist(&mut self) {
        for j in 0..MN {
            let x = (self.X[j] & MPU) +
                (self.X[(j + 1) % MN] & MPL);
            let xA = (x >> 1) ^ (MA * (x & M1));
            self.X[j] = self.X[(j + MM) % MN] ^ xA;
        }
        self.i = 0;
    }
}

impl SeedableRng<u32> for MT19937Rng {
    fn reseed(&mut self, seed: u32) {
        self.i = MN;
        self.X[0] = w(seed);
        for j in 1..MN {
            let x_p = self.X[j - 1];
            self.X[j] = MF * (x_p ^ (x_p >> (MW - 2))) + w(j as u32);
        }
    }

    fn from_seed(seed: u32) -> MT19937Rng {
        let mut rng = MT19937Rng::new_unseeded();
        rng.reseed(seed);
        rng
    }
} 

impl Rng for MT19937Rng {
    fn next_u32(&mut self) -> u32 {
        if self.i >= MN {
            self.twist();
        }

        let mut y = self.X[self.i];
        y = y ^ (y >> MU);
        y = y ^ ((y << MS) & MB);
        y = y ^ ((y << MT) & MC);
        y = y ^ (y >> ML);

        self.i += 1;
        y.0
    }
}

impl Rand for MT19937Rng {
    fn rand<R: Rng>(rng: &mut R) -> MT19937Rng {
        let seed: u32 = rng.gen();
        MT19937Rng::from_seed(seed)
    }
}

#[test]
fn test_xor_bytes() {
    assert_eq!(
        xor_bytes(&[0x12, 0x34], &[0xfe, 0xdc]),
        &[0x12 ^ 0xfe, 0x34 ^ 0xdc]);
    assert_eq!(
        xor_bytes(&[0x12, 0x34], &[0x12, 0x34]),
        &[0x00, 0x00]);
    assert_eq!(
        xor_bytes(&[0x12, 0x34], &[0x7e]),
        &[0x12 ^ 0x7e, 0x34 ^ 0x7e]);
}

#[test]
fn test_count_bits() {
    assert_eq!(0, count_bits(0x00000000));
    assert_eq!(1, count_bits(0x00000001));
    assert_eq!(13, count_bits(0x5030ff01));
    assert_eq!(16, count_bits(0x0000ffff));
    assert_eq!(20, count_bits(0xf0fff00f));
    assert_eq!(32, count_bits(0xffffffff));
}

#[test]
fn test_hamming_dist() {
    assert_eq!(0, hamming_dist(0b001, 0b001));
    assert_eq!(1, hamming_dist(0b001, 0b101));
    assert_eq!(2, hamming_dist(0b001, 0b111));
}

#[test]
fn test_bytes_hamming_dist() {
    let b1 = "this is a test".as_bytes();
    let b2 = "wokka wokka!!!".as_bytes();
    assert_eq!(37, bytes_hamming_dist(&b1, &b2))
}

