use std::num::Wrapping as w;

use rand::{Rng, SeedableRng};

use util::{MT19937Rng, w32};

// y1 = y0 ^ (y0 >> 11)
// y2 = y1 ^ ((y1 << 7) & 0x9D2C5680)
// y3 = y2 ^ ((y2 << 15) & 0xEFC60000)
// y4 = y3 ^ (y3 >> 18)

// GF(2)
//    y4 = A * y0
// => y0 = A_inv * y4

// A = np.array([
//   [1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
//   [0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],
//   [0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0],
//   [0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0],
//   [0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
//   [0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0],
//   [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
//   [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],
//   [0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
//   [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0],
//   [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0],
//   [0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,1],
//   [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0],
//   [0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0],
//   [0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
//   [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0],
//   [0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
//   [0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1]
// ])

// det = int(np.round(np.linalg.det(A)))
// A_inv = np.round(np.linalg.inv(A) * det).astype(int) % 2
// ----
// A_inv = np.array([
//   [1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0],
//   [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
//   [0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0],
//   [0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0],
//   [0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
//   [1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0],
//   [0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],
//   [0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
//   [0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1],
//   [0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0],
//   [0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1],
//   [1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0],
//   [0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0],
//   [0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0],
//   [0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1],
//   [1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
//   [0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0],
//   [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
//   [0,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,1],
//   [0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],
//   [0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0],
//   [0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1],
//   [1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0],
//   [0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0],
//   [0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1]
// ])


const A: [u32; 32] = [
    0b10001001000000010000000000000000,
    0b01000100000000001000000000000000,
    0b00100010000001000100000010000000,
    0b00010000001000000000000000000000,
    0b10001000100100010001000000100000,
    0b01000100010010000000100000000000,
    0b00000010001000000100010000001000,
    0b00010001000100100010001000000100,
    0b00000000100010000000000100000000,
    0b00000000010001000000100010000001,
    0b00000010001000000100000000000000,
    0b10000000000100000000000000000000,
    0b01000000100010000001000000000000,
    0b00100000010001000100100000001000,
    0b00010000000000100010000000000100,
    0b00001000000000010000000000000000,
    0b00000100000000001000000000000000,
    0b00000010000001000100000010000000,
    0b10001000000000010010000000000000,
    0b01000100100000011001000000100000,
    0b00100010010001000100100010000000,
    0b00010000000000000100010000001000,
    0b10001000100000010011001000100100,
    0b01000100010000000000100100000000,
    0b00000010001001000100110010001001,
    0b00010001000100000010001001000100,
    0b00000000100010010000000100100000,
    0b00000000010001001000100010010001,
    0b00000010001000000000000000001000,
    0b10000000000100000010000000000100,
    0b01000000100010000000000000000010,
    0b00100000010001000100000000001001
];

const A_INV: [u32; 32] = [
    0b10001001000100110000001000000100,
    0b01000000000000001000000000000000,
    0b00100000000000000100000000000000,
    0b00010010001001000100000010000001,
    0b01001000000100000001000000000000,
    0b01100100100010000001100000100000,
    0b00010010000000000000010000000000,
    0b00001001000100100000001000000100,
    0b00000100100000000000000100000000,
    0b00000010010000000000000010000000,
    0b00000010001001000100000010000001,
    0b10001001000000110000001000000100,
    0b00000000100010001001000000100000,
    0b00000000001001000100100000001000,
    0b00010010001101100100000010000101,
    0b01001000000100010001000000000000,
    0b01100100100010001001100000100000,
    0b00010000000001000100010010000001,
    0b10001001000100100010001000000100,
    0b01000100000000000001000100100000,
    0b00100010010000000000100010000000,
    0b00010010000001000100010010001001,
    0b10000001000100110000000000000000,
    0b00000100100010001001000100100000,
    0b00000010001000000100100010001001,
    0b00010011001101100100000011000101,
    0b01001000100100010001000000100000,
    0b01100100110010001001100000110000,
    0b00010000001001000100010010001001,
    0b10001001000000100010001000000000,
    0b01000100000010000001000100100010,
    0b00100010010001000000100010000001
];

fn temper(y0: u32) -> u32 {
    let y1 = y0 ^ (y0 >> 11);
    let y2 = y1 ^ ((y1 << 7) & 0x9D2C5680_u32);
    let y3 = y2 ^ ((y2 << 15) & 0xEFC60000_u32);
    let y4 = y3 ^ (y3 >> 18);
    y4
}

fn temper2(y0: u32) -> u32 {
    let mut y4 = 0_u32;
    for i in 0..32 {
        y4 |= ((A[31 - i] & y0).count_ones() & 1) << i;
    }
    y4
}

#[test]
fn test_temper2() {
    let mut rng = MT19937Rng::from_seed(0x12345678_u32);
    for _ in 0..1000 {
        let a = rng.next_u32();
        assert_eq!(temper(a), temper2(a));
    }
}

fn untemper(y4: u32) -> u32 {
    let mut y0 = 0_u32;
    for i in 0..32 {
        y0 |= ((A_INV[31 - i] & y4).count_ones() & 1) << i;
    }
    y0
}

#[test]
fn test_untemper() {
    let mut rng = MT19937Rng::from_seed(0x12345678_u32);
    for _ in 0..1000 {
        let a = rng.next_u32();
        assert_eq!(a, untemper(temper(a)));
    }
}

//#[test]
#[allow(non_snake_case)]
#[allow(dead_code)]
fn print_A_matrix() {
    // y1 = y0 ^ (y0 >> 11)
    let mut y1 = Vec::with_capacity(32);
    for i in 0..32 {
        let val = if i + 11 > 31 {
            1 << i
        } else {
            (1 << i) | (1 << (i + 11))
        };
        y1.push(val);
        println!("{:032b}", y1[i]);
    }
    println!("===");

    // y2 = y1 ^ ((y1 << 7) & 0x9D2C5680)
    let mut y2 = Vec::with_capacity(32);
    for i in 0..32 {
        let val = if 0x9D2C5680_u32 & (1 << i) == 0 || (i as i32) - 7 < 0 {
            y1[i]
            //format!("{}", &y1[i])
            //format!("y1[{}]", i)
        } else {
            y1[i] ^ y1[i - 7]
            //format!("{} ^ {}", &y1[i], &y1[i - 7])
            //format!("y1[{}] ^ y1[{}]", i, i - 7)
        };
        y2.push(val);
        println!("{:032b}", y2[i]);
    }
    println!("===");

    // y3 = y2 ^ ((y2 << 15) & 0xEFC60000)
    let mut y3 = Vec::with_capacity(32);
    for i in 0..32 {
        let val = if 0xEFC60000_u32 & (1 << i) == 0 || (i as i32) - 15 < 0 {
            y2[i]
            //format!("y2[{}]", i)
            //format!("{}", &y2[i])
        } else {
            y2[i] ^ y2[i - 15]
            //format!("y2[{}] ^ y2[{}]", i, i - 15)
            //format!("{} ^ {}", &y2[i], &y2[i - 15])
        };
        y3.push(val);
        println!("{:032b}", y3[i]);
    }
    println!("===");

    // y4 = y3 ^ (y3 >> 18)
    let mut y4 = Vec::with_capacity(32);
    for i in 0..32 {
        let val = if i + 18 > 31 {
            y3[i]
            //format!("y3[{}]", i)
            //format!("{}", &y3[i])
        } else {
            y3[i] ^ y3[i + 18]
            //format!("y3[{}] ^ y3[{}]", i, i + 18)
            //format!("{} ^ {}", &y3[i], &y3[i + 18])
        };
        y4.push(val);
        println!("{:032b}", y4[i]);
    }
    println!("===");

    println!("A = np.array([");
    for i in 0..32 {
        let v = y4[31-i];
        print!("    [");
        for j in 0..32 {
            if v & (1 << j) != 0 {
                print!("1");
            } else {
                print!("0");
            }
            if j != 31 {
                print!(",");
            }
        }
        if i != 31 {
            println!("],");
        } else {
            println!("]");
        }
    }
    println!("])");
    assert!(false);
}

#[test]
fn run() {
    let mut rng = MT19937Rng::from_seed(0x12345678_u32);

    let mut X: [w32; 624] = [w(0_u32); 624];

    for i in 0..624 {
        let y4 = rng.next_u32();
        let y0 = untemper(y4);
        X[i] = w(y0);
    }

    let mut rng2 = MT19937Rng::from_state(624, X);

    for _ in 0..1000 {
        let y4_1 = rng.next_u32();
        let y4_2 = rng2.next_u32();
        assert_eq!(y4_1, y4_2);
    }
}
